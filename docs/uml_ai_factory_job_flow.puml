@startuml AI Factory Simulation - Job Execution Flow
!theme plain

title AI Factory Simulation - Job Execution Sequence
footer Use PlantUML (freeware) or online renderer at plantuml.com

participant "MixedScenario" as Scenario
participant "JobRunner" as Runner
participant "DES\n(Scheduler)" as DES
participant "BarrierBookkeeper" as Book
participant "NetworkFlowInjector" as Injector
participant "Host\n(Network)" as Host

== Scenario Installation ==
Scenario -> Scenario: Allocate hosts to jobs\n(rack_balanced / contiguous)
Scenario -> Scenario: Build Job A (TP-heavy)\nBuild Job B (PP+DP)
create Runner
Scenario -> Runner: new JobRunner(sim, injector, job)
Scenario -> Runner: run()
activate Runner
Runner -> Runner: Create JobMetrics
Runner -> DES: schedule_event(0.0, _start_job)

== Job Execution ==
DES -> Runner: _start_job()
Runner -> Runner: Log job start
Runner -> Runner: _run_step(step_index=0)

loop For each step
    Runner -> Runner: Create StepMetrics
    Runner -> Runner: _run_phase(step_index, phase_index=0)

    loop For each phase in step
        alt ComputePhase
            Runner -> DES: schedule_timer(delay=duration_s, cb=done_phase)
            note right: Simulates GPU compute time
            DES -> Runner: done_phase()
        else CommPhase
            Runner -> Runner: _run_comm_phase(phase, done_phase)
            activate Runner

            loop For each bucket (sequential)
                Runner -> Book: Create Join with pending flow_ids

                loop For each flow in bucket (parallel)
                    Runner -> DES: schedule_event(delay, _inject)
                    DES -> Injector: inject(flow, on_complete=book.on_flow_complete)
                    activate Injector
                    Injector -> Injector: Register callback
                    Injector -> Host: send_message(\n  session_id=flow_id,\n  dst_ip, size_bytes)
                    deactivate Injector
                end

                note over Host: Network simulation\nhandles packet routing\nand delivery

                Host --> Injector: on_message(packet)\n[wrapped callback]
                activate Injector
                Injector -> Injector: Track bytes received
                alt Flow complete (all bytes received)
                    Injector -> Book: on_flow_complete(flow_id)
                    Book -> Book: join.mark_complete(flow_id)
                    alt All flows in bucket complete
                        Book -> Runner: done_bucket()
                        note right: Move to next bucket\nor finish phase
                    end
                end
                deactivate Injector
            end

            deactivate Runner
        end

        Runner -> Runner: _run_phase(next phase)
    end

    Runner -> Runner: _run_step(next step)
end

Runner -> Runner: Update JobMetrics.end_time
deactivate Runner

@enduml
