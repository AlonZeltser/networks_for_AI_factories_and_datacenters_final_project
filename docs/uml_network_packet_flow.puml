@startuml Network Simulation - Packet Flow Sequence
!theme plain

title Network Simulation Layer - Packet Transmission Flow
footer Use PlantUML (freeware) or online renderer at plantuml.com

participant "Host A\n(Source)" as HostA
participant "DES\n(Scheduler)" as DES
participant "Port\n(Egress)" as Port
participant "Link" as Link
participant "Switch" as Switch
participant "Host B\n(Destination)" as HostB

== Message Sending ==
HostA -> HostA: send_message(session_id, dst_ip, size_bytes)
activate HostA
note right: Packetize: split into\nMTU-sized packets
loop for each packet
    HostA -> HostA: Create Packet\n(PacketL3 + PacketTransport + TrackingInfo)
    HostA -> HostA: select_port_for_packet()
    note right: ECMP: hash-based\nADAPTIVE: min queue
    HostA -> Port: enqueue(packet)
end
deactivate HostA

== Port Drain & Link Transmission ==
Port -> DES: schedule_event(0.0, _drain_once)
activate Port
DES -> Port: _drain_once()
Port -> Port: Check link availability
alt Link available (now >= next_available_time)
    Port -> Link: transmit(packet, sender)
    activate Link
    Link -> Link: Calculate serialization delay\n(size_bytes * 8 / bandwidth)
    Link -> DES: schedule_event(arrival_time - now, deliver)
    deactivate Link
else Link busy
    Port -> DES: schedule_event(delay_until_free, _drain_once)
end
deactivate Port

== Packet Delivery ==
DES -> Switch: deliver -> post(packet)
activate Switch
Switch -> Switch: TTL -= 1, route_length += 1
Switch -> Switch: Add to inbox
Switch -> DES: schedule_event(0.0, handle_message)
DES -> Switch: handle_message()
Switch -> Switch: on_message(packet)
alt TTL > 0
    Switch -> Switch: select_port_for_packet()
    Switch -> Port: enqueue(packet)
else TTL <= 0 (expired)
    Switch -> Switch: packet.dropped = True
end
deactivate Switch

== Final Delivery to Host B ==
DES -> HostB: deliver -> post(packet)
activate HostB
HostB -> HostB: on_message(packet)
HostB -> HostB: packet.delivered = True
HostB -> HostB: Track flow completion
deactivate HostB

@enduml
